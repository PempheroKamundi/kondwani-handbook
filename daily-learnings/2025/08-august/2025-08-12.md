# August 12, 2025

## What I Learned Today

### What makes Python decorators, metaclasses, generators and context managers possible in Python

- **Main Concept**: Python is a dynamically interpreted language that executes code sequentially at both import time and runtime. Additionally, it's a protocol-oriented language that calls special methods (dunder methods) in a defined manner when they are present. These special methods are documented in the [Python Data Model](https://docs.python.org/3/reference/datamodel.html).
- **Source**: https://www.youtube.com/watch?v=cKPlPJyQrt4&t=5024s
- **Key Insights**:

#### Protocol-Oriented Design enables Context Managers
Python looks for specific method names (`__enter__`, `__exit__`) and automatically calls them, allowing objects to participate in the `with` statement protocol.

#### Sequential Execution During Definition enables Decorators  
Python executes code line-by-line when defining functions, allowing us to intercept and modify functions during their creation process.

#### Functions as First-Class Objects enables Generators
Functions can return generator objects that maintain their execution state, allowing pausable and resumable execution through the iterator protocol.

#### Dynamic Class Creation enables Metaclasses
Since Python executes code at import time, metaclasses can customize class creation and validate class definitions before the class is fully constructed, potentially catching errors early.

#### Examples in Practice:

```python
# Context Managers: Python finds and calls special methods
class FileManager:
    def __enter__(self):
        print("Opening file")
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Closing file")

with FileManager():  # Python automatically calls __enter__ and __exit__
    print("Working with file")
```

```python
# Decorators: Intercept function creation
def my_decorator(func):
    print("This runs during function definition!")
    return func

@my_decorator  # Executes during definition, not call
def my_function():
    return "hello"
```

```python
# Generators: Functions return generator objects
def my_generator():
    yield 1
    yield 2

gen = my_generator()  # Returns generator object, function body hasn't run yet
next(gen)  # NOW run until first yield
```

```python
# Metaclasses: Customize class creation
class MyMeta(type):
    def __new__(cls, name, bases, attrs):
        print(f"Creating class {name}")
        return super().__new__(cls, name, bases, attrs)

class MyClass(metaclass=MyMeta):  # Runs MyMeta.__new__ immediately
    x = 5
```

---
**Learning Time**: 2 hours
**Difficulty**: Advanced
**Would Recommend**: Yes - Learn this if you want to be a Python expert

### Learned what it means when we say a system is Reliable, Maintainable and Scalable

- **Main Concept**: Understanding these concepts is key to creating world-class systems. However, their actual meaning and definition is not as straightforward as it seems, because different systems require different interpretations of each concept. Additionally, knowing the exact meaning of these terms for a particular system enables you to choose the right technology stack to fulfill those requirements.
- **Source**: [Designing Data-Intensive Applications Book](https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321)
- **Key Insights**:
  - Systems have both functional and non-functional requirements. For example, low latency is a non-functional requirement, while being able to chat with another user is a functional requirement.
  - **Reliability** means that the system continues to perform its functional and non-functional requirements correctly even when there are faults. Note the distinction between faults and failures: faults are individual component malfunctions that you can anticipate and handle, while failures occur when the system as a whole stops providing the required service. We design fault-tolerant systems so that faults don't cause failures. Faults can arise from human error, hardware failures, and software errors.
  - **Maintainability** refers to the ease and cost of keeping software operational and evolving it over time, whether that involves adding new features or fixing bugs. As a rule of thumb, it's usually more expensive to maintain software than to initially write it, which is why it's important to consider maintainability from the start. Poor maintainability can actually affect reliability in the long run, potentially turning your software into legacy code that's difficult to update. A key principle for creating maintainable software is to avoid accidental complexityâ€”keep the system as simple and understandable as possible.
  - **Scalability** describes how well a system performs when load parameters increase. Note that I use "load parameters" rather than generic terms like "requests" because different systems have different scalability bottlenecks. For databases, it might be the read/write ratio; for a web server, it might be requests per second. When identifying bottlenecks, ask yourself: "How much load would break this system, keeping everything else constant (CPU, RAM, etc.)?" and "How much additional resources (CPU, RAM) do we need to handle the target load?" As a rule of thumb, most architectures can handle about 10x their current load with proper optimization. It's also important to understand the difference between throughput, latency, and response time, as this helps identify where system bottlenecks occur.

## Reflections

Considering maintainability, scalability, and reliability from an early stage can be the difference between a thriving startup and one that fails due to technical debt and system limitations.

---
**Learning Time**: 3 hours
**Difficulty**: Advanced
**Would Recommend**: Yes - Learn how to build systems for scale